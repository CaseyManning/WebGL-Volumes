<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <script src="perlin.js"></script>
        <script src="volumetrics.js"></script>
        <link rel="stylesheet" href="index.css">
        <link rel="icon" href="data:,">

        <script type='glsl/vertex'>#version 300 es
            in vec4 coords;

            struct Ray {
                vec3 origin;
                vec3 dir;
            };

            out Ray vRay;

 
            void main() {
                // Hardcoded for now. This should the camera position.
                vec3 cameraPosition = vec3(0.0, 0.0, 2.0);

                vRay.dir = coords.xyz - cameraPosition;
                vRay.origin = cameraPosition + vec3(0.5);
                gl_Position = coords;
            }
          </script>
          
          <script type='glsl/fragment'>#version 300 es

            precision highp float;


            precision highp sampler3D;
            uniform sampler3D uVolume;

            #define PI 3.1415925359
            #define TWO_PI 6.2831852
            #define MAX_STEPS 200
            #define MAX_DIST 200.

            #define NB_STEPS 50

            #define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)

            uniform vec2 u_resolution;
            uniform vec2 mouse;
            uniform float u_time;

            out vec4 col;

            struct Ray {
                vec3 origin;
                vec3 dir;
            };

            in Ray vRay;

            bool computeNearFar(Ray ray, inout float near, inout float far) {

                vec3 invRay = 1.0 / ray.dir;


                vec3 tbottom = - invRay * ray.origin;
                vec3 ttop = invRay * (vec3(1.0) - ray.origin);

                vec3 tmin = min(ttop, tbottom);
                vec3 tmax = max(ttop, tbottom);

                float largestMin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
                float smallestMax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));

                near = largestMin;
                far = smallestMax;

                return smallestMax > largestMin;
            }

            float getCloudDensity(vec3 pos) {
              float density = 0.;
              // float nosie = texture(uVolume, pos).r/2;
              if(length(pos - vec3(0.5, 0.5, 0.5)) < 0.2 + texture(uVolume, pos).r/2.) {
                  density = 0.05;
              } else {
                  density = 0.;
              }
              return density;
            }

            float traceShadowRay(vec3 pos) {
                vec3 dir = normalize(vec3(mouse.x, -mouse.y, 0.)) * 0.05;
                
                pos += dir* 2.5*hash(pos.xy);

                float acc = 0.;
                for (int i = 0; i < NB_STEPS/2; ++i) {
                    // Get the voxel at the current ray position.
                    float s = getCloudDensity(pos);
                    
                    // The more we already accumulated, the less opacity we apply.
                    acc += (1.0 - acc) * s;

                    pos += dir;

                    if (acc > 0.95) { break; }

                }
                return acc;
            }

            vec4 traceViewRay(Ray ray) {
                float acc = 0.;
                vec3 rgbval = vec3(0.);
                for (int i = 0; i < NB_STEPS; ++i) {
                    // Get the voxel at the current ray position.
                    float density = getCloudDensity(ray.origin);
                    
                    float shadowAmt = traceShadowRay(ray.origin);
                    // shadowAmt = ray.origin.y;

                    vec3 ambient = vec3(0.1);
                    vec3 volumeColor = vec3(0.8);

                    if(density > 0.) {
                        rgbval += (vec3(shadowAmt) + ambient) * density * volumeColor;
                    }

                    // The more we already accumulated, the less opacity we apply.
                     acc += (1.0 - acc) * density;

                    // Early termination: after this threshold, accumulating becomes insignificant.
                    if (acc > 0.95) { break; }

                    ray.origin += ray.dir;
                }
                return vec4(rgbval,acc);
            }

            mat3 rotationMatrix(vec3 axis, float angle) {
              axis = normalize(axis);
              float s = sin(angle);
              float c = cos(angle);
              float oc = 1.0 - c;
              
              return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
}
             
             void main(void) {
                // vec2 xy = gl_FragCoord.xy / u_resolution;

                //vec2 uv = (gl_FragCoord.xy-.5*u_resolution.xy)/u_resolution.y;
                
                Ray ray;
                ray.origin = vRay.origin;
                ray.dir = normalize(vRay.dir);

                // Solves a ray - Unit Box equation to determine the value of the closest and
                float near = 0.0;
                float far = 0.0;
                computeNearFar(ray, near, far);

                // Moves the ray origin to the closest intersection.
                // We don't want to spend time sampling nothing out of the volume!
                ray.origin = ray.origin + near * ray.dir;

                mat3 rot = rotationMatrix(vec3(0, 1, 0), u_time / 3.);
                ray.origin -= vec3(0.5, 0.5, 0.5);
                ray.origin = rot * ray.origin;
                ray.dir = rot * ray.dir;
                ray.origin += vec3(0.5, 0.5, 0.5);


                vec3 inc = 1.0 / abs( ray.dir );
                // Step size between two samples
                float delta = min(inc.x, min(inc.y, inc.z)) / float(NB_STEPS);
                // The ray direction is now scaled by the step size.
                ray.dir = ray.dir * delta;

                vec4 bg = vec4(0., 0., 0., 1.);

                ray.origin += ray.dir * 1.5*hash(gl_FragCoord.xy);
                vec4 result = traceViewRay(ray);

                col = bg*(1.-result.a) + result;
             }
        </script>
        <script type='glsl/vertex' id="glsl/vertex" src="shader.vert"></script>
        <script type='glsl/fragment' id="glsl/fragment" src="shader.frag"></script>
    </head>
    <body>
        <canvas id="glCanvas"></canvas>
        <p id="fpslabel">12 fps</p>
    </body>
</html>