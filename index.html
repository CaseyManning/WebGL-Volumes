<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <script src="perlin.js"></script>
        <script src="volumetrics.js"></script>
        <link rel="stylesheet" href="index.css">
        <link rel="icon" href="data:,">

        <script type='glsl/vertex'>#version 300 es
            in vec4 coords;

            struct Ray {
                vec3 origin;
                vec3 dir;
            };

            out Ray vRay;

 
            void main() {
                // Hardcoded for now. This should the camera position.
                vec3 cameraPosition = vec3(0.0, 0.0, 2.0);

                vRay.dir = coords.xyz - cameraPosition;
                vRay.origin = cameraPosition + vec3(0.5);
                gl_Position = coords;
            }
          </script>
          
          <script type='glsl/fragment'>#version 300 es

            precision highp float;


            precision highp sampler3D;
            uniform sampler3D uVolume;

            #define STEP_DIST 0.1

            #define NB_STEPS 50

            #define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)

            uniform vec2 u_resolution;
            uniform vec2 mouse;
            uniform float u_time;
            uniform float u_density;
            uniform float u_shadowfactor;
            uniform float u_light;
            uniform float u_ambient;
            uniform float u_occlusion;

            out vec4 col;

            mat3 rotationMatrix(vec3 axis, float angle) {
              axis = normalize(axis);
              float s = sin(angle);
              float c = cos(angle);
              float oc = 1.0 - c;
              
              return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
}
      

            struct Ray {
                vec3 origin;
                vec3 dir;
            };

            in Ray vRay;

            bool computeNearFar(Ray ray, inout float near, inout float far) {

                vec3 invRay = 1.0 / ray.dir;

                vec3 tbottom = - invRay * ray.origin;
                vec3 ttop = invRay * (vec3(1.0) - ray.origin);

                vec3 tmin = min(ttop, tbottom);
                vec3 tmax = max(ttop, tbottom);

                float largestMin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
                float smallestMax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));

                near = largestMin;
                far = smallestMax;

                return smallestMax > largestMin;
            }

            float getCloudDensity(vec3 pos) {
                int noiseSize = 32;
                float density = 0.;
                // float nosie = texture(uVolume, pos).r/2;
                if(length(pos - vec3(0.5, 0.5, 0.5)) < 0.2 + texture(uVolume, pos).r/2. + texture(uVolume, pos.xzy*5.).r/12.) {
                    density = u_density/200.;
                } else {
                    density = 0.;
                }
                return density;
            }

            float traceShadowRay(vec3 pos) {
                mat3 rot = rotationMatrix(vec3(0, 1, 0), u_time / 3.);
                vec3 dir = normalize(vec3(mouse.x, -mouse.y, 0.)) * 0.05;
                dir *= rot;
                // vec3 dir = normalize(vec3(1, -1, 0.)) * 0.05;
                
                pos += dir* 2.5*hash(pos.xy);

                float acc = 0.;
                for (int i = 0; i < NB_STEPS/2; ++i) {
                    float s = getCloudDensity(pos);
                    
                    // The more we already accumulated, the less opacity we apply.
                    acc += s; //(1.0 - acc) * s;

                    pos += dir;

                    if (acc > 0.95) { break; }

                }
                return acc;
            }

            float computeAmbient(vec3 pos, float stepLength) {
                float shadowdist = 0.;

                int nsteps = 2;

                float accumDensity = 0.;

                vec3 currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(0., 1., 0.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }
                currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(1., 0., 0.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }
                currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(0., 0., 1.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }
                currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(0., -1., 0.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }
                currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(-1., 0., 0.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }
                currentPos = pos.xyz;
                for(int i = 0; i < nsteps; i++) {
                    currentPos += vec3(0., 0., -1.) * stepLength;
                    accumDensity += getCloudDensity(currentPos) * 2.;
                }

                return exp(-accumDensity / u_density * 15.);
            }

            vec4 traceViewRay(Ray ray) {
                float acc = 0.;
                vec3 rgbval = vec3(0.);
                for (int i = 0; i < NB_STEPS; ++i) {
                    // Get the voxel at the current ray position.
                    float density = getCloudDensity(ray.origin);

                    float transmittance = 0.;
                    if(density > 0.) {
                        float lineardensity = traceShadowRay(ray.origin)*u_shadowfactor;
                        transmittance = exp(-lineardensity);
                    }

                    float ambocc = computeAmbient(ray.origin, length(ray.dir) * u_occlusion / 10.);

                    vec3 ambient = vec3(ambocc) * u_ambient;

                    vec3 volumeColor = vec3(1.);

                    vec3 lightColor = vec3(1., 1., 1.);
                    vec3 lightContrib = lightColor * transmittance * u_light;

                    if(density > 0.) {
                        rgbval += (lightContrib + ambient) * density * volumeColor;
                    }

                    // The more we already accumulated, the less opacity we apply.
                     acc += (1.0 - acc) * density;

                    // Early termination: after this threshold, accumulating becomes insignificant.
                    if (acc > 0.95) { break; }

                    float steplength = 1.;
                    if(density == 0.) {
                        // steplength = 1.5;
                    }
                    ray.origin += ray.dir*steplength;
                }
                return vec4(rgbval,acc);
            }

       
             void main(void) {
                // vec2 xy = gl_FragCoord.xy / u_resolution;

                //vec2 uv = (gl_FragCoord.xy-.5*u_resolution.xy)/u_resolution.y;
                
                Ray ray;
                ray.origin = vRay.origin;
                ray.dir = normalize(vRay.dir);

                // Solves a ray - Unit Box equation to determine the value of the closest and
                float near = 0.0;
                float far = 0.0;
                computeNearFar(ray, near, far);

                // Moves the ray origin to the closest intersection.
                // We don't want to spend time sampling nothing out of the volume!
                ray.origin = ray.origin + near * ray.dir;

                mat3 rot = rotationMatrix(vec3(0, 1, 0), u_time / 3.);
                ray.origin -= vec3(0.5, 0.5, 0.5);
                ray.origin = rot * ray.origin;
                ray.dir = rot * ray.dir;
                ray.origin += vec3(0.5, 0.5, 0.5);

                vec3 inc = 1.0 / abs( ray.dir );
                // Step size between two samples
                float delta = min(inc.x, min(inc.y, inc.z)) / float(NB_STEPS);
                // The ray direction is now scaled by the step size.
                ray.dir = ray.dir * delta;

                vec4 bg = vec4(0., 0., 0., 1.);

                ray.origin += ray.dir * 1.5*hash(gl_FragCoord.xy);
                vec4 result = traceViewRay(ray);

                col = bg*(1.-result.a) + result;
             }
        </script>
        <script type='glsl/vertex' id="glsl/vertex" src="shader.vert"></script>
        <script type='glsl/fragment' id="glsl/fragment" src="shader.frag"></script>
    </head>
    <body>
        <canvas id="glCanvas"></canvas>
        <div id="controls">
            <p id="fpslabel"></p>
            <div style="display: flex; flex-wrap: nowrap; margin-top: 10px;">
                <p style="margin-top: 2px; margin-right: 10px;">density</p>
                <input type="range" min="0" max="100" value="10" class="slider" id="densityslider">
            </div>
            <div style="display: flex; flex-wrap: nowrap; margin-top: 10px;">
                <p style="margin-top: 2px; margin-right: 10px;">scattering</p>
                <input type="range" min="0" max="10" value="5" class="slider" id="shadowslider">
            </div>
            <div style="display: flex; flex-wrap: nowrap; margin-top: 10px;">
                <p style="margin-top: 2px; margin-right: 10px;">directional</p>
                <input type="range" min="0" max="100" value="100" class="slider" id="lightslider">
            </div>
            <div style="display: flex; flex-wrap: nowrap; margin-top: 10px;">
                <p style="margin-top: 2px; margin-right: 10px;">ambient</p>
                <input type="range" min="0" max="100" value="10" class="slider" id="ambientslider">
            </div>
            <div style="display: flex; flex-wrap: nowrap; margin-top: 10px;">
                <p style="margin-top: 2px; margin-right: 10px;">occlusion radius</p>
                <input type="range" min="0" max="50" value="10" class="slider" id="occlusionslider">
            </div>
        </div>
        
    </body>
</html>